from __future__ import annotations

import unittest

from api.engine.layers.vulnerability_index_v1 import (
    VULNERABILITY_INDEX_V1_VERSION,
    run_vulnerability_index_v1,
)


class VulnerabilityIndexV1Tests(unittest.TestCase):
    def test_skip_when_structural_snapshot_missing(self) -> None:
        payload = run_vulnerability_index_v1(
            primitive_index_by_slot={"S0": ["SELF_MILL"]},
            deck_slot_ids_playable=["S0"],
            structural_snapshot_v1=None,
        )

        self.assertEqual(payload.get("version"), VULNERABILITY_INDEX_V1_VERSION)
        self.assertEqual(payload.get("status"), "SKIP")
        self.assertEqual(payload.get("reason"), "STRUCTURAL_SNAPSHOT_MISSING")

        self.assertEqual(
            payload.get("scores"),
            {
                "graveyard_reliance": 0.0,
                "commander_dependence": 0.0,
                "single_engine_reliance": 0.0,
                "setup_dependency": 0.0,
                "interaction_exposure": 0.0,
            },
        )

    def test_ok_scores_rounding_and_signals(self) -> None:
        payload = run_vulnerability_index_v1(
            primitive_index_by_slot={
                "S0": ["SELF_MILL", "RECURSION_TO_HAND", "TUTOR_ANY_TO_HAND"],
                "S1": [
                    "REANIMATION_TO_BATTLEFIELD",
                    "MANA_RAMP_LAND_SEARCH",
                    "CARD_DRAW_REPEATABLE",
                    "STACK_COUNTERSPELL",
                ],
                "S2": ["TUTOR_ANY_TO_HAND", "TUTOR_TO_TOP"],
                "S3": ["MANA_RAMP_ARTIFACT_ROCK", "CARD_DRAW_BURST", "TARGETED_REMOVAL_CREATURE"],
                "S4": ["TUTOR_ANY_TO_HAND", "TUTOR_TYPE_SPECIFIC", "CARD_DRAW_BURST"],
                "S5": ["TUTOR_ANY_TO_HAND"],
            },
            deck_slot_ids_playable=["S0", "S1", "S2", "S3", "S4", "S5"],
            structural_snapshot_v1={"commander_dependency_signal_v1": 0.3333333333},
        )

        self.assertEqual(payload.get("version"), VULNERABILITY_INDEX_V1_VERSION)
        self.assertEqual(payload.get("status"), "OK")
        self.assertIsNone(payload.get("reason"))

        self.assertEqual(
            payload.get("scores"),
            {
                "graveyard_reliance": 0.666667,
                "commander_dependence": 0.333333,
                "single_engine_reliance": 0.666667,
                "setup_dependency": 0.222222,
                "interaction_exposure": 0.8,
            },
        )

        signals = payload.get("signals") if isinstance(payload.get("signals"), dict) else {}
        self.assertEqual(signals.get("graveyard_slots"), 2)
        self.assertEqual(signals.get("recursion_slots"), 2)
        self.assertEqual(signals.get("commander_dependency_signal"), 0.333333)
        self.assertEqual(
            signals.get("top_primitive_concentration"),
            [
                {"primitive": "TUTOR_ANY_TO_HAND", "share": 0.666667},
                {"primitive": "CARD_DRAW_BURST", "share": 0.333333},
                {"primitive": "CARD_DRAW_REPEATABLE", "share": 0.166667},
                {"primitive": "MANA_RAMP_ARTIFACT_ROCK", "share": 0.166667},
                {"primitive": "MANA_RAMP_LAND_SEARCH", "share": 0.166667},
                {"primitive": "REANIMATION_TO_BATTLEFIELD", "share": 0.166667},
                {"primitive": "RECURSION_TO_HAND", "share": 0.166667},
                {"primitive": "SELF_MILL", "share": 0.166667},
            ],
        )
        self.assertEqual(payload.get("notes"), [])

    def test_top_primitive_concentration_ordering_breaks_ties_by_name(self) -> None:
        payload = run_vulnerability_index_v1(
            primitive_index_by_slot={
                "S0": ["TUTOR_ANY_TO_HAND", "CARD_DRAW_BURST"],
                "S1": ["CARD_DRAW_BURST"],
                "S2": ["TUTOR_ANY_TO_HAND"],
                "S3": ["MANA_RAMP_ARTIFACT_ROCK"],
            },
            deck_slot_ids_playable=["S3", "S2", "S1", "S0"],
            structural_snapshot_v1={"commander_dependency_signal_v1": 0.0},
        )

        concentration = (
            payload.get("signals", {}).get("top_primitive_concentration")
            if isinstance(payload.get("signals"), dict)
            else []
        )
        self.assertEqual(
            concentration,
            [
                {"primitive": "CARD_DRAW_BURST", "share": 0.5},
                {"primitive": "TUTOR_ANY_TO_HAND", "share": 0.5},
                {"primitive": "MANA_RAMP_ARTIFACT_ROCK", "share": 0.25},
            ],
        )

    def test_deterministic_for_same_input(self) -> None:
        kwargs = {
            "primitive_index_by_slot": {
                "S0": ["SELF_MILL", "TUTOR_ANY_TO_HAND"],
                "S1": ["STACK_COUNTERSPELL", "CARD_DRAW_BURST"],
                "S2": ["MANA_RAMP_LAND_SEARCH"],
            },
            "deck_slot_ids_playable": ["S0", "S1", "S2"],
            "structural_snapshot_v1": {"commander_dependency_signal_v1": 0.25},
        }

        first = run_vulnerability_index_v1(**kwargs)
        second = run_vulnerability_index_v1(**kwargs)

        self.assertEqual(first, second)


if __name__ == "__main__":
    unittest.main()
