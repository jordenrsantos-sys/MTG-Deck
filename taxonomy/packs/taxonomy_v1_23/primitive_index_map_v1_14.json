[{"append_only":"true","assignment_rule":"Assign integer indices in first appearance order; new primitives append to end; never renumber.","backward_compat":"Old indices remain valid; bitsets can expand with new trailing words.","id_field":"primitive_id","index_field":"primitive_index","index_space":"primitives","notes":"Critical for fast bitset ops + stable history.","storage_recommendation":"Store primitive_index_map.json in pack; store primitive_bits as varlen blob."},{"append_only":"true","assignment_rule":"Assign indices similarly; append-only; never renumber.","backward_compat":"Equiv bitsets expand similarly.","id_field":"equiv_class_id","index_field":"equiv_index","index_space":"equivalence_classes","notes":"Supports redundancy computations.","storage_recommendation":"Store equiv_index_map.json in pack; equiv_bits in varlen blob."},{"append_only":"true","assignment_rule":"Enum registries append-only per facet key; never reuse old enum ints.","backward_compat":"Old compiled facets remain valid.","id_field":"facet_key:facet_value","index_field":"enum_int","index_space":"facets_enums","notes":"Avoid JSON parsing at runtime.","storage_recommendation":"Store facet_enum_registry.json; compiled facets as packed ints."}]