from __future__ import annotations

from typing import Any, Dict, List

from api.engine.constants_disruption import DISRUPTION_PRIMITIVE_IDS


VULNERABILITY_INDEX_V1_VERSION = "vulnerability_index_v1"

_GRAVEYARD_PRIMITIVE_IDS = [
    "ARTIFACT_RECURSION",
    "CAST_FROM_GRAVEYARD",
    "REANIMATION_TO_BATTLEFIELD",
    "RECURSION_TO_HAND",
    "SELF_MILL",
    "SPELL_RECURSION_INSTANT_SORC",
    "TUTOR_TO_GRAVEYARD",
]

_RECURSION_PRIMITIVE_IDS = [
    "ARTIFACT_RECURSION",
    "CAST_FROM_GRAVEYARD",
    "REANIMATION_TO_BATTLEFIELD",
    "RECURSION_TO_HAND",
    "SPELL_RECURSION_INSTANT_SORC",
]

_TUTOR_PRIMITIVE_IDS = [
    "CREATURE_TUTOR_TO_BATTLEFIELD",
    "TUTOR_ANY_TO_BATTLEFIELD",
    "TUTOR_ANY_TO_HAND",
    "TUTOR_TO_BATTLEFIELD_LAND",
    "TUTOR_TO_EXILE_PLAY",
    "TUTOR_TO_GRAVEYARD",
    "TUTOR_TO_TOP",
    "TUTOR_TYPE_SPECIFIC",
]

_RAMP_PRIMITIVE_IDS = [
    "MANA_RAMP_ARTIFACT_ROCK",
    "MANA_RAMP_CREATURE_DORK",
    "MANA_RAMP_LAND_SEARCH",
]

_CARD_DRAW_PRIMITIVE_IDS = [
    "CARD_DRAW_BURST",
    "CARD_DRAW_REPEATABLE",
    "DEATH_PAYOFF_DRAW",
    "IMPULSE_DRAW_EXILE_PLAY",
]


def _round6(value: float) -> float:
    return float(round(value, 6))


def _clamp01(value: float) -> float:
    return max(0.0, min(1.0, float(value)))


def _nonempty_str(value: Any) -> str | None:
    if isinstance(value, str):
        token = value.strip()
        if token != "":
            return token
    return None


def _clean_sorted_unique_strings(values: Any) -> List[str]:
    if not isinstance(values, list):
        return []

    cleaned = {
        token
        for token in (_nonempty_str(value) for value in values)
        if token is not None
    }
    return sorted(cleaned)


def _clean_note_list(notes: List[Dict[str, str]]) -> List[Dict[str, str]]:
    cleaned: List[Dict[str, str]] = []
    for note in notes:
        if not isinstance(note, dict):
            continue
        code = _nonempty_str(note.get("code")) or ""
        message = _nonempty_str(note.get("message")) or ""
        cleaned.append({"code": code, "message": message})

    return sorted(
        cleaned,
        key=lambda entry: (str(entry.get("code") or ""), str(entry.get("message") or "")),
    )


def _slot_primitives(primitive_index_by_slot: Dict[str, Any], playable_slots: List[str]) -> Dict[str, List[str]]:
    return {
        slot_id: _clean_sorted_unique_strings(primitive_index_by_slot.get(slot_id))
        for slot_id in playable_slots
    }


def _count_slots_with_any(
    slot_primitives: Dict[str, List[str]],
    playable_slots: List[str],
    primitive_set: set[str],
) -> int:
    if not primitive_set:
        return 0

    return sum(
        1
        for slot_id in playable_slots
        if any(primitive in primitive_set for primitive in slot_primitives.get(slot_id, []))
    )


def _count_primitive_coverage(
    slot_primitives: Dict[str, List[str]],
    playable_slots: List[str],
    primitive_set: set[str],
) -> Dict[str, int]:
    coverage: Dict[str, int] = {}

    for slot_id in playable_slots:
        for primitive_id in slot_primitives.get(slot_id, []):
            if primitive_id not in primitive_set:
                continue
            coverage[primitive_id] = coverage.get(primitive_id, 0) + 1

    return {primitive_id: coverage[primitive_id] for primitive_id in sorted(coverage.keys())}


def _primitive_share_rows(
    primitive_counts: Dict[str, int],
    playable_slots_total: int,
    *,
    limit: int,
) -> List[Dict[str, float | str]]:
    if playable_slots_total <= 0:
        return []

    rows = [
        {
            "primitive": primitive_id,
            "share": _round6(_clamp01(count / float(playable_slots_total))),
        }
        for primitive_id, count in primitive_counts.items()
    ]

    rows_sorted = sorted(
        rows,
        key=lambda entry: (-float(entry.get("share") or 0.0), str(entry.get("primitive") or "")),
    )
    return rows_sorted[:limit]


def _base_payload(status: str, reason: str | None) -> Dict[str, Any]:
    return {
        "version": VULNERABILITY_INDEX_V1_VERSION,
        "status": status,
        "reason": reason,
        "scores": {
            "graveyard_reliance": 0.0,
            "commander_dependence": 0.0,
            "single_engine_reliance": 0.0,
            "setup_dependency": 0.0,
            "interaction_exposure": 0.0,
        },
        "signals": {
            "graveyard_slots": None,
            "recursion_slots": None,
            "commander_dependency_signal": None,
            "top_primitive_concentration": [],
        },
        "notes": [],
    }


def run_vulnerability_index_v1(
    primitive_index_by_slot: Any,
    deck_slot_ids_playable: Any,
    structural_snapshot_v1: Any = None,
) -> dict:
    if not isinstance(structural_snapshot_v1, dict):
        return _base_payload("SKIP", "STRUCTURAL_SNAPSHOT_MISSING")

    if not isinstance(primitive_index_by_slot, dict) or not isinstance(deck_slot_ids_playable, list):
        return _base_payload("SKIP", "PRIMITIVE_INDEX_UNAVAILABLE")

    payload = _base_payload("OK", None)
    notes: List[Dict[str, str]] = []

    playable_slots = _clean_sorted_unique_strings(deck_slot_ids_playable)
    playable_slots_total = len(playable_slots)
    slot_primitives = _slot_primitives(primitive_index_by_slot, playable_slots)

    all_primitive_counts = _count_primitive_coverage(
        slot_primitives=slot_primitives,
        playable_slots=playable_slots,
        primitive_set={
            primitive_id
            for slot_id in playable_slots
            for primitive_id in slot_primitives.get(slot_id, [])
        },
    )

    top_primitive_concentration = _primitive_share_rows(
        primitive_counts=all_primitive_counts,
        playable_slots_total=playable_slots_total,
        limit=8,
    )

    top_share = float(top_primitive_concentration[0].get("share") or 0.0) if top_primitive_concentration else 0.0
    payload["scores"]["single_engine_reliance"] = _round6(_clamp01(top_share))
    payload["signals"]["top_primitive_concentration"] = top_primitive_concentration

    graveyard_set = set(_clean_sorted_unique_strings(_GRAVEYARD_PRIMITIVE_IDS))
    recursion_set = set(_clean_sorted_unique_strings(_RECURSION_PRIMITIVE_IDS))
    if not graveyard_set:
        notes.append(
            {
                "code": "MISSING_GRAVEYARD_PRIMITIVES",
                "message": "Graveyard primitive definitions are unavailable.",
            }
        )
    else:
        graveyard_slots = _count_slots_with_any(
            slot_primitives=slot_primitives,
            playable_slots=playable_slots,
            primitive_set=graveyard_set,
        )
        recursion_slots = _count_slots_with_any(
            slot_primitives=slot_primitives,
            playable_slots=playable_slots,
            primitive_set=recursion_set,
        )

        payload["signals"]["graveyard_slots"] = graveyard_slots
        payload["signals"]["recursion_slots"] = recursion_slots

        graveyard_ratio = graveyard_slots / float(max(1, playable_slots_total))
        payload["scores"]["graveyard_reliance"] = _round6(_clamp01(graveyard_ratio * 2.0))

    commander_dependency_raw = structural_snapshot_v1.get("commander_dependency_signal_v1")
    if isinstance(commander_dependency_raw, (int, float)) and not isinstance(commander_dependency_raw, bool):
        commander_signal = _round6(_clamp01(float(commander_dependency_raw)))
        payload["signals"]["commander_dependency_signal"] = commander_signal
        payload["scores"]["commander_dependence"] = commander_signal
    else:
        notes.append(
            {
                "code": "MISSING_COMMANDER_DEPENDENCY_SIGNAL",
                "message": "Commander dependency signal is unavailable in structural snapshot.",
            }
        )

    tutor_set = set(_clean_sorted_unique_strings(_TUTOR_PRIMITIVE_IDS))
    ramp_set = set(_clean_sorted_unique_strings(_RAMP_PRIMITIVE_IDS))
    draw_set = set(_clean_sorted_unique_strings(_CARD_DRAW_PRIMITIVE_IDS))

    if not tutor_set or not ramp_set or not draw_set:
        notes.append(
            {
                "code": "MISSING_SETUP_PRIMITIVES",
                "message": "Setup dependency primitive definitions are incomplete.",
            }
        )
    else:
        tutor_slots = _count_slots_with_any(slot_primitives, playable_slots, tutor_set)
        ramp_slots = _count_slots_with_any(slot_primitives, playable_slots, ramp_set)
        draw_slots = _count_slots_with_any(slot_primitives, playable_slots, draw_set)

        tutor_share = tutor_slots / float(max(1, playable_slots_total))
        ramp_share = ramp_slots / float(max(1, playable_slots_total))
        draw_share = draw_slots / float(max(1, playable_slots_total))

        setup_raw = tutor_share * (1.0 - min(1.0, ramp_share + draw_share)) * 2.0
        payload["scores"]["setup_dependency"] = _round6(_clamp01(setup_raw))

    disruption_set = set(_clean_sorted_unique_strings(DISRUPTION_PRIMITIVE_IDS))
    if not disruption_set:
        notes.append(
            {
                "code": "MISSING_DISRUPTION_PRIMITIVES",
                "message": "Disruption primitive definitions are unavailable.",
            }
        )
    else:
        disruption_slots = _count_slots_with_any(slot_primitives, playable_slots, disruption_set)
        interaction_score = 1.0 - min(1.0, disruption_slots / 10.0)
        payload["scores"]["interaction_exposure"] = _round6(_clamp01(interaction_score))

    payload["notes"] = _clean_note_list(notes)

    return payload
